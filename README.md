# Monkey_Compiler

# **🟨 1. 컴파일러와 가상머신**

### **🔹 컴파일러란?**

컴파일러는 **소스 코드 → 바이트코드(Bytecode)** 로 변환하는 프로그램이다.

여기서 바이트코드는 가상머신이 실행할 수 있는 저수준 명령어로 구성된다. 🖥️

📌 예제 코드

```go

let a = 5 + 10;

```

이 코드를 컴파일하면 다음과 같은 바이트코드가 생성된다.

📌 변환된 바이트코드

```nasm

OpConstant 5
OpConstant 10
OpAdd
OpSetGlobal 0
```

- `OpConstant 5` → 스택에 5를 푸시
- `OpConstant 10` → 스택에 10을 푸시
- `OpAdd` → 스택에서 두 값을 꺼내 덧셈 연산
- `OpSetGlobal 0` → 결과를 전역 변수 `a`에 저장

---

### **🔹 가상머신(Virtual Machine, VM)이란?**

가상머신은 바이트코드를 해석하고 실행하는 소프트웨어다.

**CPU 대신 소프트웨어적으로 명령어를 실행하는 것**이라고 보면 된다.

📌 VM 실행 과정

1. 바이트코드를 로드하고, 명령어를 순차적으로 실행한다.
2. 스택(Stack)을 사용하여 연산을 수행한다.
3. 결과 값을 저장하거나 출력한다.

📌 간단한 VM 구현 코드 (Go)

```go

func (vm *VM) run() error {
    for vm.ip < len(vm.instructions) {
        op := code.Opcode(vm.instructions[vm.ip])
        switch op {
        case code.OpConstant:
            constIndex := code.ReadUint16(vm.instructions[vm.ip+1:])
            vm.ip += 2
            err := vm.push(vm.constants[constIndex])
            if err != nil {
                return err
            }
        case code.OpAdd:
            right := vm.pop()
            left := vm.pop()
            result := left + right
            vm.push(result)
        }
        vm.ip++
    }
    return nil
}
```

- `OpConstant` → 스택에 숫자 푸시
- `OpAdd` → 스택에서 두 값을 꺼내 더함
- `run()` 메서드는 바이트코드를 순차적으로 실행

이처럼 **컴파일러가 변환한 바이트코드를 실행하는 역할**이 가상머신이다. 💡

---

# **🟨 2. Hello Bytecode!**

### **🔹 바이트코드 개념 이해하기**

```go

let add = fn(a, b) { a + b; };
```

위 코드를 컴파일하면, 함수의 바이트코드가 생성된다.

📌 변환된 바이트코드

```nasm

OpGetLocal 0
OpGetLocal 1
OpAdd
OpReturnValue
```

- `OpGetLocal 0` → 첫 번째 인자 `a` 가져오기
- `OpGetLocal 1` → 두 번째 인자 `b` 가져오기
- `OpAdd` → 두 값을 더하기
- `OpReturnValue` → 결과 반환

함수를 가상머신에서 실행하면, 이 바이트코드가 순차적으로 처리되면서 결과가 반환된다. 🎯

---

# **🟨 3. 표현식 컴파일하기**

### **🔹 스택을 사용한 연산 처리**

모든 연산은 스택을 기반으로 수행된다.

📌 예제 코드

```go

1 + 2 * 3;
```

📌 바이트코드 변환 결과

```nasm

OpConstant 2
OpConstant 3
OpMul
OpConstant 1
OpAdd
OpPop
```

📌 가상머신 실행 과정

1. `2` 푸시
2. `3` 푸시
3. `OpMultiply` 실행 → `2 * 3 = 6`
4. `1` 푸시
5. `OpAdd` 실행 → `1 + 6 = 7`

즉, **중위표현식 → 후위표현식(스택기반)으로 변환** 후 실행하는 방식이다. 🔢

---

# **🟨 5. 조건식 컴파일하기**

### **🔹 if 문을 바이트코드로 변환**

`if` 문은 **조건을 검사**하고, 조건이 참일 때는 **if 블록**을 실행하고, 거짓일 때는 **else 블록**을 실행하는 구조이다. 이를 바이트코드로 변환할 때는 **점프 명령어**인 `OpJump`와 `OpJumpNotTruthy`를 사용하여 실행 흐름을 제어한다.

### 📌 예시 코드

```go

if (x > 10) {
    return x;
} else {
    return 0;
}
```

### **🔹 컴파일 과정**

1️⃣ **조건 검사**:

- `x > 10`을 **비교 연산자**로 처리하여 조건을 평가한다.
- 조건이 참이면 `OpReturnValue`가 실행되어 `x`를 반환하고, 거짓이면 else 블록으로 점프한다.

2️⃣ **조건이 참일 경우 (if 블록 실행)**:

- 조건이 참이면 **if 블록**을 실행하고 `x`를 반환한다.
- `OpReturnValue` 명령어로 `x`의 값을 반환한다.

3️⃣ **조건이 거짓일 경우 (else 블록 실행)**:

- 조건이 거짓이면 `OpJump` 명령어로 **else 블록**으로 점프하여, `OpConstant 0`과 `OpReturnValue`를 통해 0을 반환한다.

### **🔹 바이트코드 변환 결과**

```nasm

OpGetLocal 0        // 변수 x를 가져오기
OpConstant 10       // 상수 10
OpGreaterThan       // x > 10 비교
OpJumpNotTruthy 10  // false일 경우 10번 위치로 점프 (else 블록)
OpGetLocal 0        // 변수 x를 가져오기 (if 블록)
OpReturnValue       // x 반환
OpJump 12           // if 블록 실행 후 12번 위치로 점프 (else 건너뛰기)
OpConstant 0        // 상수 0 (else 블록)
OpReturnValue       // 0 반환
```

### **🔹 조건문 처리 흐름**

1. **`x > 10`** 비교 후 결과:
    - 조건이 참(true)일 경우:
        - `OpReturnValue`를 통해 `x`를 반환한다.
    - 조건이 거짓(false)일 경우:
        - `OpJumpNotTruthy`로 `else` 블록으로 점프하고, `OpReturnValue`를 통해 `0`을 반환한다.
2. **점프 명령어**:
    - `OpJumpNotTruthy`: 조건이 **거짓**일 경우 지정된 위치로 **점프**.
    - `OpJump`: `if` 블록 실행 후 **else**를 건너뛰기 위해 **점프**한다.

---

# **🟨 5. 이름을 추적하는 방법 (심벌 테이블과 바인딩 컴파일)**

## **🔹 심벌 테이블(Symbol Table)이란?**

- **심벌 테이블(Symbol Table)** 은 **변수, 함수 등의 이름을 저장하고 관리하는 자료구조**이다.

컴파일러가 **변수나 함수의 위치를 추적**하는 데 필수적이다.

📌 **심벌 테이블이 필요한 이유**

✅ **변수 및 함수 이름을 숫자(주소)로 변환하여 관리**

✅ **전역 변수와 지역 변수 구분**

✅ **스코프(범위) 관리**

## **🔹 심벌 테이블 구조 (Go 구현)**

심벌 테이블은 **해시 맵**을 사용하여 변수 및 함수 이름을 저장한다.

📌 **기본적인 심벌 테이블 구조**

```go

type SymbolTable struct {
    store map[string]Symbol  // 변수 및 함수 저장
    outer *SymbolTable       // 상위 스코프 참조
}
```

- **`store`** → 현재 스코프의 심벌들을 저장하는 맵
- **`outer`** → 상위 스코프를 참조 (중첩된 스코프 지원)

📌 **심벌(Symbol) 구조체**

```go

type Symbol struct {
    Name  string // 변수명 또는 함수명
    Scope string // 전역 또는 지역
    Index int    // 심벌의 위치 (컴파일러에서 참조)
}
```

- **`Name`** → 변수나 함수 이름
- **`Scope`** → 전역(`Global`), 지역(`Local`), 내장(`Builtin`), 자유(`Free`) 등
- **`Index`** → 변수 또는 함수의 **위치(인덱스)**

## **🔹 변수 선언과 심벌 테이블 업데이트**

📌 예제 코드

```go

let a = 5;
```

📌 **컴파일러가 변수를 처리하는 과정**

1️⃣ **`let a = 5;` 문장을 만나면**

- **숫자 5를 `OpConstant` 명령어로 컴파일**
- **변수 `a`를 심벌 테이블에 등록**

2️⃣ **심벌 테이블에서 `a`의 위치 결정**

- 현재 범위(전역/지역) 확인 후 **전역 변수로 등록**

📌 **컴파일 결과 (바이트코드)**

```nasm

OpConstant 5   // 5를 상수 테이블에 추가
OpSetGlobal 0  // 변수 a를 전역 변수로 저장
```

- `OpConstant 5` → 숫자 `5`를 **상수 테이블**에 추가
- `OpSetGlobal 0` → 전역 심벌 테이블에 `a` 저장

📌 **심벌 테이블 상태 (전역 스코프)**

```go

{
    "a": { Name: "a", Scope: "Global", Index: 0 }
}
```

## **🔹 지역 변수와 심벌 테이블 확장**

📌 예제 코드

```go

fn() {
    let b = 10;
}
```

📌 **컴파일러가 `b`를 처리하는 과정**

1️⃣ **새로운 심벌 테이블 생성 (함수의 로컬 스코프)**

- 함수 내부에서 `let b = 10;`을 만나면 **새로운 심벌 테이블을 생성**
- `b`를 **지역(Local) 변수**로 등록

2️⃣ **컴파일 결과 (바이트코드)**

```nasm

OpConstant 10  // 10을 상수 테이블에 추가
OpSetLocal 0   // 지역 변수 b를 현재 프레임에 저장
```

- `OpConstant 10` → 10을 **상수 테이블**에 추가
- `OpSetLocal 0` → 지역 변수 `b`를 현재 스택 프레임에 저장

📌 **심벌 테이블 상태 (지역 스코프)**

```go

{
    "b": { Name: "b", Scope: "Local", Index: 0 }
}
```

## **🔹 자유 변수(Closure) 처리**

📌 **자유 변수란?**

- **클로저 내부에서 외부 스코프의 변수를 참조**하는 변수
- 심벌 테이블에서 **Free 변수 목록**을 유지하여 추적

📌 예제 코드

```go

fn(x) {
    fn(y) {
        x + y
    }
}
```

📌 **컴파일 과정**

```nasm

OpGetFree 0    // 자유 변수 x 가져오기
OpGetLocal 0   // 지역 변수 y 가져오기
OpAdd
OpReturnValue
```

- `OpGetFree 0` → 외부 함수에서 선언된 `x`를 가져옴
- `OpGetLocal 0` → 내부 함수에서 선언된 `y`를 가져옴

📌 **심벌 테이블 상태 (클로저 스코프)**

```go

{
    "x": { Name: "x", Scope: "Free", Index: 0 },
    "y": { Name: "y", Scope: "Local", Index: 0 }
}
```

---

# **🟨 6. 문자열, 배열, 해시**

## **🔹 문자열 컴파일**

문자열은 **상수**로 처리되며, 문자열을 바이트코드로 변환할 때는 **상수 테이블에 저장**하고, 

이후 `OpConstant` 명령어를 사용하여 해당 문자열을 로드한다.

### 📌 예시 코드

```go

let str = "Hello, World!";
```

### **🔹 바이트코드 변환 과정**

1️⃣ `OpConstant "Hello, World!"`:

- 문자열 `"Hello, World!"`을 상수 테이블에 푸시한다.

2️⃣ `OpSetGlobal 0`:

- 문자열 `"Hello, World!"`을 **전역 변수**로 저장하기 위해 `OpSetGlobal` 명령어를 사용하여 `str` 변수에 저장한다.

### **🔹 변환된 바이트코드**

```nasm

OpConstant "Hello, World!"
OpSetGlobal 0
```

- `OpConstant` 명령어로 문자열 `"Hello, World!"`를 상수 테이블에 푸시하고, `OpSetGlobal` 명령어로 해당 문자열을 **전역 변수**에 할당한다.

## **🔹 배열 컴파일**

배열은 여러 개의 값을 하나로 묶는 자료형으로, `OpArray` 명령어를 사용하여 바이트코드로 변환할 수 있다. 배열을 만들기 위해서는 각 배열의 요소들을 먼저 **상수**로 스택에 푸시하고, 이후 `OpArray` 명령어로 해당 배열을 생성한다.

### 📌 예시 코드

```go

let arr = [1, 2, 3];
```

### **🔹 바이트코드 변환 과정**

1️⃣ `OpConstant 1`, `OpConstant 2`, `OpConstant 3`:

- 배열의 각 요소인 `1`, `2`, `3`을 상수 테이블에 푸시한다.
- 각 값은 **상수**로 처리되어 스택에 푸시된다.

2️⃣ `OpArray 3`:

- `3`은 배열의 길이를 나타내며, 스택에 푸시된 **3개의 상수**(`1`, `2`, `3`)를 사용해 배열을 생성한다.
- `OpArray` 명령어는 스택에서 **3개의 값을 가져와 배열**을 만들고 이를 스택에 푸시한다.

3️⃣ `OpSetGlobal 0`:

- 배열을 **전역 변수**로 저장하기 위해 `OpSetGlobal` 명령어를 사용하여 `arr`라는 이름의 전역 변수에 배열을 저장한다.

### **🔹 변환된 바이트코드**

```nasm

OpConstant 1
OpConstant 2
OpConstant 3
OpArray 3
OpSetGlobal 0
```

- `OpConstant` 명령어로 각 요소를 상수 테이블에 푸시하고, `OpArray 3`으로 3개의 요소를 가진 배열을 만들며, 최종적으로 `OpSetGlobal` 명령어를 통해 전역 변수에 배열을 할당한다.

## **🔹 해시 테이블 컴파일**

해시 테이블은 **키-값** 쌍으로 데이터를 저장하는 자료구조이다. Go 언어에서 해시 테이블을 컴파일하기 위해서는 먼저 각 **키**와 **값**을 상수로 스택에 푸시한 후, `OpHash` 명령어로 해시를 생성한다.

### 📌 예시 코드

```go

let h = {"key": "value"};
```

### **🔹 바이트코드 변환 과정**

1️⃣ `OpConstant "key"`:

- `"key"`라는 문자열을 **상수 테이블**에 푸시한다.

2️⃣ `OpConstant "value"`:

- `"value"`라는 문자열을 **상수 테이블**에 푸시한다.

3️⃣ `OpHash 2`:

- `2`는 해시 테이블의 **키-값 쌍의 수**를 나타내며, 스택에 푸시된 `"key"`와 `"value"`를 사용하여 해시 테이블을 만든다.
- `OpHash` 명령어는 스택에서 두 개의 값을 가져와 **해시 테이블**을 생성하고, 이를 스택에 푸시한다.

4️⃣ `OpSetGlobal 0`:

- 생성된 해시 테이블을 **전역 변수**로 저장하기 위해 `OpSetGlobal` 명령어를 사용하여 `h`라는 이름의 전역 변수에 해시 테이블을 할당한다.

### **🔹 변환된 바이트코드**

```nasm

OpConstant "key"
OpConstant "value"
OpHash 2
OpSetGlobal 0
```

- `OpConstant` 명령어로 `"key"`와 `"value"`를 상수 테이블에 푸시하고, `OpHash 2`로 2개의 키-값 쌍을 가진 해시 테이블을 생성한 후, `OpSetGlobal` 명령어로 전역 변수에 해시 테이블을 저장한다.

---

# **🟨 7. 함수**

## **🔹 함수 표현 (Function Expression)**

함수 표현은 함수를 **값으로 취급**하여 변수에 할당하거나 다른 함수의 인수로 전달하는 방식이다. 함수는 **일급 객체**로 취급되어 값처럼 다룰 수 있다.

### 📌 예시 코드

```go

let add = fn(a, b) { return a + b; };
```

- `fn(a, b)`는 **함수 리터럴**로, 매개변수 `a`, `b`를 받아 더하는 기능을 한다.
- `add`는 `fn(a, b)` 함수 리터럴을 **값**으로 받아 **변수**에 할당된다.

## **🔹 함수 스코프 추가 (Adding Function Scope)**

함수는 **스코프**(scope)를 생성한다. 함수 내부에서 선언된 변수는 그 함수의 **지역 변수**로만 유효하며, 외부에서는 접근할 수 없다. 이를 통해 **캡슐화**가 가능하다.

### 📌 예시 코드

```go

fn outer() {
    let a = 5;
    fn inner() { return a; }
    return inner;
}
```

- `outer` 함수는 **스코프**를 생성하고, `inner` 함수는 이 **스코프의 변수** `a`를 참조한다.
- `inner` 함수는 `a`를 **자유 변수**로 캡처하여 클로저를 생성한다.

### 📌 바이트코드 변환

```nasm

OpConstant 5
OpSetLocal 0
OpClosure 1, 0
OpReturnValue
```

- `OpSetLocal 0`은 `a`를 `outer` 함수의 **지역 변수**로 저장한다.
- `OpClosure 1, 0`은 `inner` 함수를 **클로저**로 만들어 자유 변수 `a`를 캡처한다.

## **🔹 함수 호출 컴파일 (Compiling Function Call)**

함수 호출을 컴파일할 때는 **인수 전달**과 **반환값**을 처리한다. 함수 호출은 **스택**을 이용해 인수를 전달하고, 실행 후에는 **반환값**을 스택에서 꺼낸다.

### 📌 예시 코드

```go

let result = add(3, 4);
```

- `add(3, 4)` 호출 시, **인수** `3`과 `4`는 스택에 푸시되고, 함수는 이 값을 처리한 후 **결과**를 반환한다.

### 📌 바이트코드 변환

```nasm

OpConstant 3
OpConstant 4
OpCall 2
OpSetGlobal 0
```

- `OpConstant`는 인수 `3`과 `4`를 스택에 푸시한다.
- `OpCall 2`는 **2개의 인수**를 전달하여 `add` 함수를 호출한다.
- `OpSetGlobal 0`은 결과를 전역 변수에 저장한다.

## **🔹 함수 프레임 (Function Frame)**

함수를 호출할 때마다 **함수 프레임**이 스택에 푸시된다. 이 프레임은 함수 실행에 필요한 **지역 변수**, **매개변수**, **반환 주소**를 저장한다. 함수 실행이 끝나면 프레임은 스택에서 팝(pop)되어 제거된다.

### 📌 함수 호출 시 프레임의 구성

- **매개변수**는 함수의 **입력값**을 저장한다.
- **지역 변수**는 함수 내부에서만 유효한 변수들이다.
- **반환 주소**는 함수 실행이 끝난 후 돌아갈 위치를 나타낸다.

### 📌 예시

```go

fn add(a, b) {
    let sum = a + b;
    return sum;
}
```

1️⃣ **함수 호출**: `add(3, 4)`가 호출된다.

2️⃣ **프레임 푸시**: `add` 함수의 프레임이 스택에 푸시되고, 매개변수 `a`와 `b`가 설정된다.

3️⃣ **지역 변수**: `sum`이 함수 내부에서 생성되고, `a + b` 값이 저장된다.

4️⃣ **반환**: `sum`이 반환값으로 설정되고, 함수 프레임이 스택에서 팝된다.

## **🔹 지역 바인딩 (Local Binding)**

지역 바인딩은 함수 내에서 **지역 변수**를 선언하고 실행 중에 사용할 수 있게 한다. 

지역 변수들은 함수 실행 중에는 **스택**에 저장되고, 함수가 종료되면 사라진다. 

지역 변수들은 함수 스코프 내에서만 유효하며, 외부에서는 접근할 수 없다. 

이러한 동작은 심벌 테이블을 확장하여 구현할 수 있다.

### 📌 예시 코드

```go

fn example() {
    let a = 5;
    return a;
}
```

- `let a = 5`는 `a`라는 **지역 변수**를 선언하고 값을 `5`로 설정한다.
- `a`는 **지역 바인딩**을 통해 함수 실행 중에만 유효하며, 함수가 종료되면 사라진다.

### **🔹 심벌 테이블을 활용한 지역 바인딩**

지역 변수를 관리하는데 **심벌 테이블**을 확장할 수 있다. 심벌 테이블은 변수의 이름과 해당 값을 **지역 범위**에서 관리하며, 함수가 호출될 때마다 **새로운 심벌 테이블**을 생성하여 지역 변수를 추적한다. 심벌 테이블은 각 함수의 **스코프**에 해당하는 **구조체**로 정의된다.

### 📌 심벌 테이블 예시 코드

```go

type SymbolTable struct {
    store map[string]interface{}
    outer *SymbolTable
}

func NewSymbolTable(outer *SymbolTable) *SymbolTable {
    return &SymbolTable{
        store: make(map[string]interface{}),
        outer: outer,
    }
}
```

- `SymbolTable`는 지역 및 외부 변수들을 관리하는 자료구조로, **현재 스코프의 지역 변수**와 그 **외부 스코프**의 변수들까지 추적할 수 있다.

### 📌 지역 바인딩을 활용한 함수 예시

```go

fn example() {
    let a = 5;   // 지역 변수 a 선언
    return a;
}
```

1️⃣ **새로운 심벌 테이블 생성**: `example` 함수가 호출되면 새로운 심벌 테이블이 생성되어 **지역 변수**인 `a`를 관리한다.

2️⃣ **변수 설정**: `let a = 5`는 `a`라는 변수에 값을 설정하고 심벌 테이블에 저장된다.

3️⃣ **지역 변수 사용**: `a`는 심벌 테이블에 저장된 값으로, `OpGetLocal 0` 명령어가 이를 조회하고 반환한다.

### 📌 바이트코드 변환

```nasm

OpConstant 5
OpSetLocal 0
OpGetLocal 0
OpReturnValue
```

- `OpSetLocal 0`: `a`를 **지역 변수**로 설정한다. 이 값은 심벌 테이블에서 관리된다.
- `OpGetLocal 0`: `a`의 값을 스택에 푸시하고 반환한다.

### **🔹 함수 실행 시 지역 변수 관리**

함수가 호출될 때마다 **새로운 심벌 테이블**이 생성되고, 함수의 **지역 변수**는 해당 테이블에 저장된다. 함수가 종료되면 그 심벌 테이블은 **스택에서 팝**되며, 해당 변수들은 더 이상 유효하지 않게 된다.

### **프레임 구조체와 심벌 테이블 확장**

각 함수 호출마다 **프레임**(Frame)이 생성되며, 해당 프레임에서 사용되는 **지역 변수**들은 심벌 테이블을 통해 관리된다.

```go
type Frame struct {
	cl          *object.Closure
	ip          int
	basePointer int
}

func NewFrame(cl *object.Closure, basePointer int) *Frame {
	return &Frame{cl: cl, ip: -1, basePointer: basePointer}
}

func (f *Frame) Instructions() code.Instructions {
	return f.cl.Fn.Instructions
}
```

- **심벌 테이블을 프레임에 포함**하여 각 함수의 지역 변수를 **프레임 내에서 관리**할 수 있다.
- 함수가 호출될 때, 해당 프레임의 **심벌 테이블**에서 지역 변수들을 추적하고, 함수 종료 후 프레임과 함께 해당 심벌 테이블도 제거된다.

### 📌 프레임에서 지역 변수 추적

프레임 내에서 **지역 변수를 설정**하고 **조회**할 때 심벌 테이블을 활용하여 관리한다. 이는 함수 실행 중에만 유효한 변수들을 추적하는 중요한 역할을 한다.

### **🔹 지역 바인딩의 전체적인 흐름**

1. 함수가 호출되면 **새로운 프레임**과 **심벌 테이블**이 생성된다.
2. **지역 변수**들은 해당 심벌 테이블에 저장된다.
3. 함수가 종료되면 **프레임**과 **심벌 테이블**이 제거된다.
4. 지역 변수는 함수의 스코프 밖에서는 접근할 수 없으며, 함수 호출 시마다 새로운 심벌 테이블을 생성하여 **캡슐화**가 이루어진다.

## **🔹 함수 호출 인수 (Function Call Arguments)**

함수 호출 시 **인수**는 **스택**을 통해 전달된다. 함수는 이 인수들을 **스택에서 꺼내** 처리하고, **반환값**을 다시 스택에 푸시한다.

### 📌 예시 코드

```go

let result = add(3, 4);
```

- `add` 함수는 `3`과 `4`를 **인수**로 받아 **스택에 푸시**한다.
- 함수 실행 후, **결과**가 스택에 푸시된다.

### 📌 바이트코드 변환

```nasm

OpConstant 3
OpConstant 4
OpCall 2
OpSetGlobal 0
```

- `OpConstant`는 인수 `3`과 `4`를 스택에 푸시한다.
- `OpCall 2`는 2개의 인수를 받는 `add` 함수를 호출한다.
- `OpSetGlobal 0`은 결과를 전역 변수에 저장한다.

### **🔹 컴파일된 함수 (Compiled Function)**

**컴파일된 함수**는 실행 시 **코드 블록**과 **바이트코드**로 변환되어 실행된다. 함수의 **클로저**는 코드와 자유 변수를 캡처하여 실행 시 이를 참조할 수 있다.

### 📌 `compiledFunction` 구조체

```go

type CompiledFunction struct {
    Instructions code.Instructions // 함수 바이트코드
    NumLocals    int               // 함수 내 지역 변수 수
    NumArguments int               // 함수 인수 수
}
```

- **Instructions**: 함수의 바이트코드를 저장하며, 순차적으로 실행된다.
- **NumLocals**: 함수 내에서 사용할 **지역 변수**의 수를 나타낸다.
- **NumArguments**: 함수가 받을 **인수**의 수를 나타낸다.

### 📌 예시: 컴파일된 함수 호출

```go

fn add(a, b) {
    let sum = a + b;
    return sum;
}
```

1️⃣ `add` 함수는 **컴파일된 함수**로 변환되어 바이트코드로 저장된다.

2️⃣ 함수 호출 시 `OpConstant`, `OpCall` 등의 바이트코드 명령어가 생성되어 인수를 스택에 푸시하고, 실행 후 결과를 반환한다.

---

# **🟨 8. 내장 함수**

내장 함수는 **언어 자체에 미리 정의된 함수**로, 사용자가 정의하지 않아도 호출할 수 있는 함수들이다. 

내장 함수는 특정 기능을 빠르고 효율적으로 수행하기 위해 가상 머신에서 미리 처리된 코드로 구현된다. 

예를 들어, `len` 함수는 배열이나 문자열의 길이를 구하는 내장 함수이다.

### **🔹 내장 함수 목록 관리**

내장 함수는 **고정된 인덱스**로 관리된다. 

예를 들어, `len` 함수는 인덱스 `0`, `print` 함수는 인덱스 `1` 등으로 설정된다. 

이러한 함수들은 가상 머신에서 **내장 함수 테이블**로 관리되어, 호출 시 인덱스를 통해 해당 함수에 접근한다.

```go
var Builtins = []struct {
	Name    string
	Builtin *Builtin
}{
	{
		"len",
		&Builtin{Fn: func(args ...Object) Object {
			if len(args) != 1 {
				return newError("wrong number of arguments. got=%d, want=1", len(args))
			}
			switch arg := args[0].(type) {
			case *Array:
				return &Integer{Value: int64(len(arg.Elements))}
			case *String:
				return &Integer{Value: int64(len(arg.Value))}
			default:
				return newError("argument to `len` not supported, got %s", args[0].Type())
			}
		},
		},
	},
	// 다른 내장 함수들 ...
```

- **내장 함수 테이블**은 함수 인덱스를 **키**로 사용하고, 해당 함수의 **실제 구현**을 **값**으로 사용한다.
- `OpGetBuiltin` 명령어는 이 테이블을 참조하여 내장 함수를 호출한다.

### **🔹 내장 함수 예제 (`len`)**

```go

len([])
```

- `len` 함수는 **배열 또는 슬라이스**의 길이를 반환하는 내장 함수이다.
- 배열 `[1, 2, 3]`의 길이는 `3`이며, `len` 함수는 이 값을 반환한다.

### 📌 바이트코드 변환

```nasm

OpGetBuiltin 0
OpArray 0
OpCall 1
OpPop
```

- `OpConstant 0`: 배열 `[]`을 **스택**에 푸시한다.
- `OpGetBuiltin 0`: 내장 함수 `len`을 호출한다. `0`은 내장 함수 목록에서 `len` 함수의 인덱스를 나타낸다.
- `OpCall 1`: 함수 호출 시 **1개의 인수**를 전달하며, `len` 함수는 이를 처리한다.
- `OpPop`: 반환값을 사용하지 않으므로 **스택에서 결과를 팝**한다.

### **🔹 내장 함수 호출**

내장 함수 호출은 일반적인 함수 호출과 비슷하지만, 다음과 같은 차이점이 있다:

- 내장 함수는 **가상 머신에 미리 정의**되어 있으며, 일반적인 함수처럼 바이트코드로 변환되지만, 그 구현은 **외부 라이브러리**나 **가상 머신 내장 코드**로 처리된다.
- 내장 함수는 **고정된 인덱스**를 가지며, 이를 통해 호출된다. `OpGetBuiltin` 명령어는 내장 함수 호출을 나타내며, 내장 함수 목록에서 해당 함수의 **인덱스**를 사용한다.

---

# **🟨 9. 클로저 (Closure)**

## **🔹 클로저란?**

클로저는 **함수와 그 함수가 선언된 환경**을 함께 저장하는 객체이다. 즉, 함수는 자신이 선언된 스코프(변수들의 환경)에 대한 **참조**를 자유 변수(free variable)로 캡처하여 클로저를 만든다. 이 자유 변수들은 함수가 반환될 때에도 해당 스코프에 남아 있어, 함수가 실행될 때 그 값을 참조할 수 있게 된다.

## **🔹 클로저의 동작 방식**

클로저는 **중첩된 함수**를 통해 자유 변수들을 캡처한다. 예를 들어, `fn(a)` 안에 `fn(b)`가 있고, 그 안에 다시 `fn(c)`가 있다면, 각 함수는 자신이 속한 스코프에 있는 변수를 로컬 변수(local variable)로 갖고, 그보다 바깥에 있는 변수를 자유 변수(free variable)로 캡처한다.

### 📌 예시 코드

```go

fn(a){
    fn(b){
        fn(c){
            a + b + c;
        }
    }
}
```

위 코드는 `a`, `b`, `c` 변수를 사용하여 `a + b + c`를 계산하는 **3중 중첩 함수**를 정의한다.

1. `fn(c)`에서는 `a`, `b`를 자유 변수로, `c`를 로컬 변수로 사용한다.
2. `fn(b)`에서는 `a`를 자유 변수로, `b`를 로컬 변수로 사용한다.
3. `fn(a)`에서는 `a`를 로컬 변수로 사용한다.

### **🔹 바이트코드 변환**

이 코드를 바이트코드로 변환하면, 각 함수는 다음과 같은 명령어들을 가진다:

```nasm

OpGetFree 0      ; a (자유 변수)
OpGetFree 1      ; b (자유 변수)
OpAdd            ; a + b
OpGetLocal 0     ; c (로컬 변수)
OpAdd            ; a + b + c
OpReturnValue    ; 결과 반환

OpGetFree 0      ; a (자유 변수)
OpGetLocal 0     ; b (로컬 변수)
OpClosure 0, 1   ; fn(c)를 클로저로 만들어 반환
OpReturnValue    ; fn(b) 반환

OpGetLocal 0     ; a (로컬 변수)
OpClosure 1, 2   ; fn(b)를 클로저로 만들어 반환
OpReturnValue    ; fn(a) 반환
```

### **🔹 명령어 설명**

- `OpGetFree 0`, `OpGetFree 1`: 자유 변수인 `a`와 `b`를 가져온다.
- `OpGetLocal 0`: 로컬 변수 `c`를 가져온다.
- `OpAdd`: 값을 더하는 연산을 수행한다.
- `OpClosure 0, 1`: 클로저를 생성하여 `a`와 `b`를 캡처하고 반환한다.
- `OpReturnValue`: 값을 반환한다.

## **🔹 자유 변수 컴파일 및 환원**

클로저 내부에서 자유 변수를 컴파일하고 환원하는 과정은 변수의 스코프를 적절히 처리하는 중요한 부분이다. 예를 들어, `fn(c)`에서는 `a`와 `b`를 자유 변수로 캡처하고, `fn(b)`에서는 `a`를 자유 변수로 캡처한다. 이를 위해 심벌 테이블을 통해 변수의 스코프를 확인하고, **재귀적으로 스코프를 타고 올라가며** 각 변수가 자유 변수인지 로컬 변수인지를 결정한다.

### 📌 심벌 테이블의 `Resolve` 메서드

```go

func (s *SymbolTable) Resolve(name string) (Symbol, bool) {
	obj, ok := s.store[name]
	if !ok && s.Outer != nil {
		obj, ok = s.Outer.Resolve(name) // 재귀적으로 부모 스코프를 확인
		if !ok {
			return obj, ok
		}

		if obj.Scope == GlobalScope || obj.Scope == BuiltinScope {
			return obj, ok
		}
		free := s.defineFree(obj)
		return free, true
	}
	return obj, ok
}
```

- `Resolve` 메서드는 변수를 찾기 위해 **스코프를 타고 올라가며** 변수의 정의를 찾는다.
- `obj.Scope`가 `GlobalScope`나 `BuiltinScope`인 경우 전역 변수나 내장 함수를 반환하고, 그렇지 않으면 **자유 변수**를 정의하여 반환한다.

## **🔹 런타임에서 클로저 만들기**

클로저는 런타임에 함수와 그 함수가 캡처한 자유 변수를 함께 저장하는 객체이다. 이는 함수가 실행되는 시점에 **자유 변수를 캡처**하고, 함수의 실행이 종료되더라도 **자유 변수를 계속 참조**할 수 있게 해준다. 예를 들어, `fn(a)`에서 `fn(b)`가 호출될 때 `a`를 자유 변수로 캡처하고, 그 안에서 `fn(c)`를 호출하여 `a`, `b`를 자유 변수로 캡처한다.

## **🔹 재귀적 클로저**

재귀적 클로저는 **자기 자신을 참조하는 클로저**로, 특히 반복적인 계산을 수행할 때 유용하다. 예를 들어, 팩토리얼 계산 함수나 피보나치 수열 같은 경우 재귀적인 클로저를 사용하여 **함수 호출 자체를 클로저로 캡처**한다.

### 📌 예시 코드 (재귀적 클로저)

```go

fn factorial(n) {
    fn fact(n) {
        if n == 0 {
            return 1;
        }
        return n * fact(n-1);
    }
    return fact(n);
}
```

위 코드에서 `fact` 함수는 자기 자신을 **재귀적으로 호출**하는 **재귀적 클로저**이다. 이 클로저는 `fact(n)`을 호출할 때마다 이전 값들을 캡처하여 계산을 수행한다.

---

# **🟨 10. 갈무리**

## **🔹성능 벤치마크: `eval` 엔진 vs `vm` 엔진**

벤치마크 테스트를 통해 두 가지 실행 엔진(`eval`과 `vm`)의 성능 차이를 비교하였다. 

테스트는 피보나치 수열 계산을 기반으로 진행되었으며, 각 엔진에서의 실행 시간을 기록하였다.

### **벤치마크 결과**

1. **`eval` 엔진 (인터프리터)**
    - **결과**: 9227465
    - **소요 시간**: 17.81초
2. **`vm` 엔진 (컴파일러 & 가상머신)**
    - **결과**: 9227465
    - **소요 시간**: 6.26초

### **결과 분석**

- **`eval` 엔진**은 피보나치 수열을 계산하는 데 **17.81초**가 소요되었다. 이는 각 계산이 즉시 평가(evaluated)되는 방식으로 동작하여 실행 시간이 길어질 수 있다.
- **`vm` 엔진**은 피보나치 수열 계산을 **6.26초**에 완료하였다. 이는 가상 머신(VM) 환경에서 명령어를 **최적화된 방식으로 실행**하여 더 빠른 성능을 보인다.

## **🔹얻은점**

- **단일 기능 메서드**: 메서드는 하나의 단일 기능을 최대한 집중하여 구현하는 것이 중요하다.
- **클로저 학습**: 9장 클로저에 대한 부분은 다소 어려웠으며, 추후 다시 확인해야 할 필요가 있다. 책을 보면서 이해가 되지 않는 부분은 디버깅을 통해 해결하려 노력했고, 대부분은 이해할 수 있었다. 현재는 백지 상태에서 코딩을 할 수는 없지만, 책의 코드를 통해 내용을 이해할 수 있는 수준에 도달했다.
- **컴파일러 이해**: 컴파일러의 구조와 원리에 대한 이해가 조금씩 향상되었으며, 특히 **AST를 명령어로 변환하고, 그 명령어를 가상 머신이 실행하는 과정**과 **조건식에서 점프 명령어를 생성하여 반환점으로 돌아오는 과정**에 대해 배웠다. 스택을 통한 연산과 **함수 호출 프레임을 스택으로 구현**한 부분은 실제로 체험해 보면서 간접적인 이해를 할 수 있었다.
- **프로젝트 성찰**: 많은 것을 얻었지만, 돌이켜보면 중요한 내용을 기억하는 데에는 아쉬움이 남았다. 부족한 점을 느끼며 이를 자양분 삼아 더욱 정진할 것이다. 또한 이 책을 다시 볼 예정이다.
- **성능 측정 경험**: **인터프리터와 컴파일러, 가상 머신의 성능을 직접 측정**하면서 두 방식에 대한 견해를 넓힐 수 있었다.
